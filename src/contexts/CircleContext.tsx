import React, { createContext, useContext, useEffect, useState } from 'react';
import { supabase } from '../lib/supabaseClient';
import { useAuth } from './AuthContext';

export type Circle = {
  id: string;
  name: string;
  join_code: string;
  created_by: string;
  created_at: string;
};

export type CircleMember = {
  id: string;
  circle_id: string;
  user_id: string;
  role: 'admin' | 'member';
  status: 'pending' | 'accepted' | 'rejected';
  joined_at: string | null;
};

export type CircleWithMembership = Circle & {
  membership: CircleMember;
};

type CircleContextType = {
  circles: CircleWithMembership[];
  pendingCircles: CircleWithMembership[];
  loading: boolean;
  createCircle: (name: string) => Promise<Circle>;
  joinCircle: (joinCode: string) => Promise<void>;
  fetchCircles: () => Promise<void>;
  getPendingRequests: (circleId: string) => Promise<CircleMember[]>;
  acceptMember: (memberId: string) => Promise<void>;
  rejectMember: (memberId: string) => Promise<void>;
  removeMember: (memberId: string) => Promise<void>;
  regenerateJoinCode: (circleId: string) => Promise<string>;
};

const CircleContext = createContext<CircleContextType | undefined>(undefined);

export function CircleProvider({ children }: { children: React.ReactNode }) {
  const { user } = useAuth();
  const [circles, setCircles] = useState<CircleWithMembership[]>([]);
  const [pendingCircles, setPendingCircles] = useState<CircleWithMembership[]>([]);
  const [loading, setLoading] = useState(true);
  // Fetch accepted and pending circles for the current user
  const fetchCircles = async () => {
    if (!user) {
      setCircles([]);
      setPendingCircles([]);
      setLoading(false);
      return;
    }

    setLoading(true);
    try {
      const { data, error } = await supabase
        .from('circle_members')
        .select(`
          id,
          circle_id,
          user_id,
          role,
          status,
          joined_at,
          circles:circle_id (
            id,
            name,
            join_code,
            created_by,
            created_at
          )
        `)
        .eq('user_id', user.id)
        .in('status', ['accepted', 'pending']);

      if (error) throw error;

      const allCircles: CircleWithMembership[] = (data || []).map((row: any) => ({
        id: row.circles.id,
        name: row.circles.name,
        join_code: row.circles.join_code,
        created_by: row.circles.created_by,
        created_at: row.circles.created_at,
        membership: {
          id: row.id,
          circle_id: row.circle_id,
          user_id: row.user_id,
          role: row.role,
          status: row.status,
          joined_at: row.joined_at,
        },
      }));

      // Separate accepted and pending
      setCircles(allCircles.filter(c => c.membership.status === 'accepted'));
      setPendingCircles(allCircles.filter(c => c.membership.status === 'pending'));
    } catch (err) {
      console.error('Error fetching circles:', err);
    } finally {
      setLoading(false);
    }
  };

  // Create a new circle and add creator as admin
  const createCircle = async (name: string): Promise<Circle> => {
    if (!user) throw new Error('User not authenticated');

    // Insert circle (join_code will be auto-generated by database)
    const { data: circle, error: circleError } = await supabase
      .from('circles')
      .insert({
        name,
        created_by: user.id,
      })
      .select()
      .single();

    if (circleError) {
      console.error('Circle creation error:', circleError);
      throw circleError;
    }

    // Add creator as admin with accepted status
    const { error: memberError } = await supabase
      .from('circle_members')
      .insert({
        circle_id: circle.id,
        user_id: user.id,
        role: 'admin',
        status: 'accepted',
        joined_at: new Date().toISOString(),
      });

    if (memberError) throw memberError;

    await fetchCircles();
    return circle;
  };

  // Join a circle using join code (creates pending membership)
  const joinCircle = async (joinCode: string): Promise<void> => {
    if (!user) throw new Error('User not authenticated');

    // Find circle by join code
    console.log('Looking up circle with code:', joinCode.toUpperCase());
    const { data: circles, error: circleError } = await supabase
      .from('circles')
      .select('id, name, join_code')
      .eq('join_code', joinCode.toUpperCase());

    console.log('Circle lookup result:', { circles, error: circleError });

    if (circleError) {
      console.error('Database error:', circleError);
      throw new Error('Failed to lookup circle');
    }

    if (!circles || circles.length === 0) {
      console.error('No circle found with code:', joinCode);
      throw new Error('Invalid join code. Please check the code and try again.');
    }

    const circle = circles[0];

    // Check if already a member
    const { data: existing } = await supabase
      .from('circle_members')
      .select('id, status')
      .eq('circle_id', circle.id)
      .eq('user_id', user.id)
      .single();

    if (existing) {
      if (existing.status === 'accepted') {
        throw new Error('You are already a member of this circle');
      } else if (existing.status === 'pending') {
        throw new Error('Your membership request is pending approval');
      }
    }

    // Insert pending membership
    const insertData = {
      circle_id: circle.id,
      user_id: user.id,
      role: 'member',
      status: 'pending',
    };
    console.log('Attempting to insert membership:', insertData);
    
    const { data: memberData, error: memberError } = await supabase
      .from('circle_members')
      .insert(insertData)
      .select()
      .single();

    if (memberError) {
      console.error('Join circle error:', memberError);
      throw memberError;
    }
    
    console.log('Membership inserted - returned data:', memberData);
    
    if (memberData.status !== 'pending') {
      console.error('WARNING: Status changed from pending to', memberData.status);
    }
    
    // Note: membership won't show in circles list until accepted
  };

  // Get pending membership requests for a circle (admin only)
  const getPendingRequests = async (circleId: string): Promise<CircleMember[]> => {
    const { data, error } = await supabase
      .from('circle_members')
      .select('*')
      .eq('circle_id', circleId)
      .eq('status', 'pending');

    if (error) throw error;
    return data || [];
  };

  // Accept a pending member (admin only)
  const acceptMember = async (memberId: string): Promise<void> => {
    const { error } = await supabase
      .from('circle_members')
      .update({
        status: 'accepted',
        joined_at: new Date().toISOString(),
      })
      .eq('id', memberId);

    if (error) throw error;
  };

  // Reject a pending member (admin only)
  const rejectMember = async (memberId: string): Promise<void> => {
    const { error } = await supabase
      .from('circle_members')
      .update({ status: 'rejected' })
      .eq('id', memberId);

    if (error) throw error;
  };

  // Remove a member (admin only)
  const removeMember = async (memberId: string): Promise<void> => {
    const { error } = await supabase
      .from('circle_members')
      .delete()
      .eq('id', memberId);

    if (error) throw error;
  };

  // Regenerate join code for a circle (admin only)
  const regenerateJoinCode = async (circleId: string): Promise<string> => {
    // Call database function to generate new unique code
    const { data, error } = await supabase.rpc('generate_unique_join_code');
    
    if (error) throw error;
    
    const newCode = data as string;

    const { error: updateError } = await supabase
      .from('circles')
      .update({ join_code: newCode })
      .eq('id', circleId);

    if (updateError) throw updateError;

    await fetchCircles();
    return newCode;
  };


  useEffect(() => {
    fetchCircles();
  }, [user]);

  return (
    <CircleContext.Provider
      value={{
        circles,
        loading,
        createCircle,
        joinCircle,
        fetchCircles,
        getPendingRequests,
        acceptMember,
        rejectMember,
        removeMember,
        regenerateJoinCode,
        pendingCircles,
      }}
    >
      {children}
    </CircleContext.Provider>
  );
}

export function useCircles() {
  const context = useContext(CircleContext);
  if (!context) throw new Error('useCircles must be used within CircleProvider');
  return context;
}

